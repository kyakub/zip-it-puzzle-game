<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZIP Puzzle Game</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #fff;
            color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }

        h1 {
            margin-bottom: 20px;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .instructions {
            margin-bottom: 20px;
            text-align: center;
        }

        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(5, 60px);
            /* 60px ширина ячейки */
            grid-template-rows: repeat(5, 60px);
            /* 60px высота ячейки */
            gap: 2px;
            /* Расстояние между ячейками */
            margin-bottom: 20px;
            position: relative;
        }

        .cell {
            width: 60px;
            /* Ширина ячейки */
            height: 60px;
            /* Высота ячейки */
            border: 2px solid #000;
            text-align: center;
            font-size: 20px;
            /* Уменьшенный размер текста */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            border-radius: 5px;
            user-select: none;
            /* Отключение выделения текста */
        }

        .cell.selected {
            background-color: #3498db;
            color: #fff;
        }

        .buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            /* Расстояние между кнопками */
            margin-top: 20px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: 3px solid black;
            /* Черная окантовка */
            background-color: white;
            /* Белый фон */
            transition: background-color 0.2s ease;
            /* Эффект перехода */
        }

        button:hover {
            background-color: blue;
            /* Синий фон при наведении */
            color: white;
            /* Белый текст при наведении */
        }

        .line {
            position: absolute;
            background-color: rgba(0, 255, 0, 0.7);
            /* Зеленый цвет для постоянной линии */
            z-index: 1;
            height: 10px;
            border-radius: 5px;
            pointer-events: none;
            transition: width 0.1s ease, transform 0.1s ease;
        }

        .line.temp {
            background-color: rgba(0, 0, 255, 0.5);
            /* Синий цвет для временной линии */
        }

        button:focus {
            outline: none;
        }

        /* Error message style */
        .error-message {
            background-color: #ffcccc;
            /* Красный фон для ошибок */
            color: red;
            /* Красный текст для ошибок */
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 5px;
            width: 300px;
            text-align: center;
            display: none;
            /* Скрыто по умолчанию */
            transition: background-color 0.3s ease, color 0.3s ease;
            /* Плавный переход для изменения стиля */
        }

        .message-box {
            display: block;
            align-items: center;
            background-color: white;
            color: black;
            font-size: .85em;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 6px 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transform: translateX(0);
            transition: opacity 0.3s ease, transform 0.3s ease;
            position: relative;
            z-index: 1000;
            word-wrap: break-word;
            margin-bottom: 8px;
        }

        .message-box span {
            flex-grow: 1;
            margin-right: 10px;
        }

        .message-box .close-button {
            background: none;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            color: black;
            padding: 0;
        }

        .message-box .close-button:hover {
            color: red;
        }

        #messageContainer {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: grid;
            justify-items: end;
        }
    </style>
</head>

<body>

    <div class="game-container">
        <h1>ZIP Puzzle Game</h1>

        <!-- Таймер -->
        <div id="timer" style="font-size: 20px; margin-bottom: 20px;">Время: 00:00</div>

        <!-- Очки -->
        <div id="score" style="font-size: 20px; margin-bottom: 20px;">Очки: 0</div>

        <!-- Puzzle Grid -->
        <div id="puzzleGrid" class="puzzle-grid"></div>

        <!-- Buttons for Undo and Restart -->
        <div class="buttons">
            <button id="undoButton">Назад</button>
            <button id="restartButton">Перезапуск</button>
        </div>
    </div>

    <div id="messageContainer"></div>

    <script>
        // Global variables
        const MESSAGE_DISPLAY_TIME = 10000; // Время отображения сообщений в миллисекундах (10 секунд)
        const gridSize = 5;
        const puzzleGrid = document.getElementById('puzzleGrid');
        let currentPuzzle = [];
        let lineElements = []; // Array to hold all drawn lines
        let isDrawing = false; // To check if the user is dragging
        let isPathStarted = false; // Флаг для отслеживания, начат ли путь

        // Добавить таймер в JavaScript
        let timerInterval;

        function startTimer() {

            let timeRemaining = 120; // Устанавливаем 2 минуты (120 секунд)
            const timerElement = document.getElementById('timer');

            timerInterval = setInterval(() => {
                const minutes = String(Math.floor(timeRemaining / 60)).padStart(2, '0');
                const seconds = String(timeRemaining % 60).padStart(2, '0');
                timerElement.textContent = `Время: ${minutes}:${seconds}`;

                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    showGameOverMessage(); // Показываем сообщение о проигрыше
                }

                timeRemaining--;
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        // Добавить подсчет очков
        let score = 0;

        function updateScore() {
            const scoreElement = document.getElementById('score');
            scoreElement.textContent = `Очки: ${score}`;
            localStorage.setItem('currentScore', score); // Сохраняем очки в локальное хранилище
        }

        function loadScore() {
            const savedScore = localStorage.getItem('currentScore');
            if (savedScore !== null) {
                score = parseInt(savedScore, 10); // Загружаем сохраненные очки
                updateScore(); // Обновляем отображение очков на странице
            }
        }

        // Добавить звуки
        const correctSound = new Audio('correct.mp3');
        const errorSound = new Audio('error.mp3');

        function playCorrectSound() {
            correctSound.play();
        }

        function playErrorSound() {
            errorSound.play();
        }

        // Сохранение прогресса
        function saveProgress() {
            const progress = {
                currentPuzzle,
                currentPath,
                timeElapsed,
                score,
            };
            localStorage.setItem('zipPuzzleProgress', JSON.stringify(progress));
        }

        // Загрузка прогресса
        function loadProgress() {
            const savedProgress = localStorage.getItem('zipPuzzleProgress');
            if (savedProgress) {
                const { currentPuzzle: savedPuzzle, currentPath: savedPath, timeElapsed: savedTime, score: savedScore } = JSON.parse(savedProgress);
                currentPuzzle = savedPuzzle;
                currentPath = savedPath;
                timeElapsed = savedTime;
                score = savedScore;
                initializePuzzle();
                startTimer();
            }
        }

        // Инициализация сетки с числами и проверка их расположения
        function initializePuzzle() {
            currentPuzzle = [];
            currentPath = [];
            lineElements = [];

            // Очистить сетку
            puzzleGrid.innerHTML = '';

            // Создать массив чисел 1-6 и пустых блоков
            let numbers = Array.from({ length: gridSize * gridSize }, (_, i) => (i < 6 ? i + 1 : null));
            numbers = shuffle(numbers);

            // Проверить, чтобы числа не блокировали путь
            while (!isValidNumberPlacement(numbers)) {
                numbers = shuffle(numbers);
            }

            // Создать сетку
            for (let i = 0; i < gridSize; i++) {
                let row = [];
                for (let j = 0; j < gridSize; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.dataset.value = numbers[i * gridSize + j];

                    if (numbers[i * gridSize + j] !== null) {
                        const numberElement = document.createElement('span');
                        numberElement.textContent = numbers[i * gridSize + j];
                        cell.appendChild(numberElement);
                    }

                    cell.addEventListener('mousedown', handleMouseDown);
                    cell.addEventListener('mousemove', handleMouseMove);
                    cell.addEventListener('mouseup', handleMouseUp);
                    row.push(cell);
                    puzzleGrid.appendChild(cell);
                }
                currentPuzzle.push(row);
            }
        }

        // Проверка, чтобы числа не блокировали путь
        function isValidNumberPlacement(numbers) {
            const grid = [];
            for (let i = 0; i < gridSize; i++) {
                grid.push(numbers.slice(i * gridSize, (i + 1) * gridSize));
            }

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] !== null) {
                        const neighbors = [
                            [i - 1, j], // вверх
                            [i + 1, j], // вниз
                            [i, j - 1], // влево
                            [i, j + 1], // вправо
                        ];
                        for (const [ni, nj] of neighbors) {
                            if (ni >= 0 && ni < gridSize && nj >= 0 && nj < gridSize) {
                                const neighborValue = grid[ni][nj];
                                if (neighborValue !== null && Math.abs(neighborValue - grid[i][j]) === 1) {
                                    return false; // Числа рядом
                                }
                            }
                        }
                    }
                }
            }
            return true;
        }

        // Shuffle array for random number placement
        function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // Функция для рисования линии между двумя ячейками
        function drawLine(fromCell, toCell) {
            const fromRect = fromCell.getBoundingClientRect();
            const toRect = toCell.getBoundingClientRect();
            const gridRect = puzzleGrid.getBoundingClientRect();

            const x1 = fromRect.left + fromRect.width / 2 - gridRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - gridRect.top;
            const x2 = toRect.left + toRect.width / 2 - gridRect.left;
            const y2 = toRect.top + toRect.height / 2 - gridRect.top;

            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);

            const line = document.createElement('div');
            line.classList.add('line');
            line.style.width = `${length}px`;
            line.style.transformOrigin = '0 50%';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1 - 5}px`;

            puzzleGrid.appendChild(line);
            lineElements.push(line);
        }

        // Обновленная функция для нахождения пути между двумя ячейками
        function findPath(fromCell, toCell) {
            const start = { row: parseInt(fromCell.dataset.row), col: parseInt(fromCell.dataset.col) };
            const end = { row: parseInt(toCell.dataset.row), col: parseInt(toCell.dataset.col) };

            const queue = [start];
            const visited = new Set();
            const cameFrom = {};

            visited.add(`${start.row},${start.col}`);

            while (queue.length > 0) {
                const current = queue.shift();
                const key = `${current.row},${current.col}`;

                if (current.row === end.row && current.col === end.col) {
                    // Построить путь
                    const path = [];
                    let step = key;
                    while (step) {
                        const [row, col] = step.split(',').map(Number);
                        path.unshift({ row, col });
                        step = cameFrom[step];
                    }
                    return path;
                }

                // Проверяем соседей
                const neighbors = [
                    { row: current.row - 1, col: current.col }, // вверх
                    { row: current.row + 1, col: current.col }, // вниз
                    { row: current.row, col: current.col - 1 }, // влево
                    { row: current.row, col: current.col + 1 }, // вправо
                ];

                for (const neighbor of neighbors) {
                    const neighborKey = `${neighbor.row},${neighbor.col}`;
                    if (
                        neighbor.row >= 0 &&
                        neighbor.row < gridSize &&
                        neighbor.col >= 0 &&
                        neighbor.col < gridSize &&
                        !visited.has(neighborKey)
                    ) {
                        const neighborCell = currentPuzzle[neighbor.row][neighbor.col];
                        const neighborValue = parseInt(neighborCell.dataset.value);

                        // Игнорируем блоки с числами, которые не соответствуют последовательности
                        if (
                            neighborValue === null || // Пустой блок
                            isNaN(neighborValue) || // Пустой блок
                            neighborValue === parseInt(toCell.dataset.value) // Блок с числом, соответствующим последовательности
                        ) {
                            visited.add(neighborKey);
                            cameFrom[neighborKey] = key;
                            queue.push(neighbor);
                        }
                    }
                }
            }

            return null; // Путь не найден
        }

        // Обновленная функция для рисования пути
        function drawPath(fromCell, toCell) {
            const path = findPath(fromCell, toCell);
            if (!path) {
                showMessage("Допустимый путь не найден!");
                return;
            }

            for (let i = 0; i < path.length - 1; i++) {
                const current = path[i];
                const next = path[i + 1];

                const currentCell = currentPuzzle[current.row][current.col];
                const nextCell = currentPuzzle[next.row][current.col];

                // Закрашиваем текущую ячейку
                if (!currentCell.classList.contains('selected')) {
                    currentCell.classList.add('selected');
                }

                drawLine(currentCell, nextCell);
            }

            // Закрашиваем конечную ячейку
            if (!toCell.classList.contains('selected')) {
                toCell.classList.add('selected');
            }

            // Проверяем завершение игры
            checkGameCompletion();
        }

        // Проверка завершения игры
        function checkGameCompletion() {
            console.log("checkGameCompletion вызвана"); // Отладочный вывод
            const allCells = document.querySelectorAll('.cell');
            const allSelected = Array.from(allCells).every(cell => cell.classList.contains('selected'));

            if (allSelected) {
                console.log("Все ячейки выбраны"); // Отладочный вывод
                const lastValue = parseInt(currentPath[currentPath.length - 1]?.dataset.value);
                if (lastValue === 6) {
                    console.log("Игра завершена успешно"); // Отладочный вывод
                    showMessage("Поздравляем! Вы успешно завершили игру!");
                    stopTimer();
                    score += 1;
                    updateScore();
                    disableGameInteraction();
                } else {
                    console.log("Игра завершена неправильно"); // Отладочный вывод
                    showMessage("Ошибка: Вы должны завершить путь на числе 6!");
                }
            } else {
                console.log("Не все ячейки выбраны"); // Отладочный вывод
                const lastValue = parseInt(currentPath[currentPath.length - 1]?.dataset.value);
                if (lastValue === 6) {
                    showMessage("Игра не завершена: не все ячейки заполнены!");
                } else {
                    showMessage("Игра еще не завершена. Продолжайте рисовать путь!");
                }
            }
        }

        // Обработчик для начала рисования линии
        function handleMouseDown(e) {
            const cell = e.target.closest('.cell');
            if (!cell) return;

            const value = parseInt(cell.dataset.value);

            // Проверка: путь можно начинать только с числа 1
            if (currentPath.length === 0 && value !== 1) {
                showMessage("Вы должны начать путь с числа 1!"); // Сообщение об ошибке
                playErrorSound();
                return;
            }

            // Проверка: если путь уже начат, продолжить можно только с последней ячейки
            if (currentPath.length > 0 && cell !== currentPath[currentPath.length - 1]) {
                showMessage("Вы можете продолжить только с последней ячейки пути!"); // Сообщение об ошибке
                playErrorSound();
                return;
            }

            console.log("handleMouseDown вызвана для ячейки:", cell.dataset.value); // Отладочный вывод

            isDrawing = true;

            // Если ячейка еще не выбрана, добавляем ее в путь
            if (!currentPath.includes(cell)) {
                currentPath.push(cell);
                console.log("currentPath обновлен:", currentPath.map(c => c.dataset.value)); // Отладочный вывод
                cell.classList.add('selected');
            }
        }

        // Connection matrix for valid connections
        const connectionMatrix = {
            1: [2],
            2: [3],
            3: [4],
            4: [5],
            5: [6],
            6: [7],
            7: [8],
            8: [9],
            9: [10],
            10: []
        };

        function isValidConnection(fromValue, toValue) {
            return connectionMatrix[fromValue].includes(toValue);
        }

        // Обновленный обработчик для рисования линии при движении мыши
        function handleMouseMove(e) {
            if (!isDrawing) return;

            const cell = e.target.closest('.cell');
            if (!cell) return;

            const lastCell = currentPath[currentPath.length - 1];

            // Если пользователь двигается вперед
            if (!cell.classList.contains('selected')) {
                // Проверяем, что ячейка является соседней (только вверх, вниз, влево или вправо)
                if (!isNeighbor(lastCell, cell)) return;

                // Добавляем текущую ячейку в путь
                currentPath.push(cell);
                cell.classList.add('selected');

                // Рисуем линию между последней и текущей ячейкой
                drawLine(lastCell, cell);
            }
            // Если пользователь двигается назад
            else if (currentPath.length > 1 && currentPath[currentPath.length - 2] === cell) {
                // Удаляем последнюю линию
                const lastLine = lineElements.pop();
                if (lastLine) {
                    lastLine.remove();
                }

                // Убираем выделение последней ячейки
                const lastCell = currentPath.pop();
                lastCell.classList.remove('selected');
            }
        }

        // Проверка соседства ячеек
        function isNeighbor(cell1, cell2) {
            const row1 = parseInt(cell1.dataset.row);
            const col1 = parseInt(cell1.dataset.col);
            const row2 = parseInt(cell2.dataset.row);
            const col2 = parseInt(cell2.dataset.col);

            // Проверяем, что ячейки находятся либо в одной строке, либо в одном столбце
            return (
                (row1 === row2 && Math.abs(col1 - col2) === 1) || // Горизонтальное соседство
                (col1 === col2 && Math.abs(row1 - row2) === 1)    // Вертикальное соседство
            );
        }

        // Обработчик для завершения рисования линии
        function handleMouseUp() {
            isDrawing = false;
            checkGameCompletion(); // Проверяем завершение игры
        }

        // Find a cell by its value
        function findCellByValue(value) {
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (currentPuzzle[i][j].dataset.value == value) {
                        return currentPuzzle[i][j];
                    }
                }
            }
            return null;
        }

        // Undo the last action
        document.getElementById('undoButton').addEventListener('click', () => {
            if (currentPath.length > 1) { // Убедимся, что есть хотя бы одна линия для удаления
                const lastCell = currentPath.pop(); // Удаляем последнюю ячейку из пути
                lastCell.classList.remove('selected'); // Убираем выделение ячейки

                const lastLine = lineElements.pop(); // Удаляем последнюю линию
                if (lastLine) {
                    lastLine.remove();
                }
            } else {
                showMessage("Невозможно отменить дальше!"); // Используем универсальную функцию
            }
        });

        // Обработчик для перезапуска игры
        document.getElementById('restartButton').addEventListener('click', () => {
            clearInterval(timerInterval); // Останавливаем текущий таймер
            initializePuzzle(); // Перезапускаем игровую сетку
            startTimer(); // Запускаем новый таймер
            currentPath = [];
            lineElements.forEach(line => line.remove());
            lineElements = [];
            isPathStarted = false; // Сбрасываем флаг начала пути
        });

        // Сохранять прогресс при каждом действии
        document.addEventListener('mouseup', saveProgress);

        // Initialize the puzzle when the page loads
        window.onload = () => {
            loadScore(); // Загружаем очки из локального хранилища
            loadProgress(); // Загружаем прогресс игры
        };

        let tempLine = null; // Временная линия для отображения в реальном времени

        function createTempLine() {
            if (!tempLine) {
                tempLine = document.createElement('div');
                tempLine.classList.add('line', 'temp'); // Добавляем класс временной линии
                puzzleGrid.appendChild(tempLine);
            }
        }

        function updateTempLine(fromCell, toCell) {
            createTempLine(); // Убедимся, что временная линия создана
            const fromRect = fromCell.getBoundingClientRect();
            const toRect = toCell.getBoundingClientRect();
            const gridRect = puzzleGrid.getBoundingClientRect();

            const x1 = fromRect.left + fromRect.width / 2 - gridRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - gridRect.top;
            const x2 = toRect.left + toRect.width / 2 - gridRect.left;
            const y2 = toRect.top + toRect.height / 2 - gridRect.top;

            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);

            tempLine.style.width = `${length}px`;
            tempLine.style.height = `10px`; // Толщина линии
            tempLine.style.position = 'absolute';
            tempLine.style.backgroundColor = 'rgba(0, 0, 255, 0.5)'; // Синий цвет для временной линии
            tempLine.style.transformOrigin = '0 50%';
            tempLine.style.transform = `rotate(${angle}deg)`;
            tempLine.style.left = `${x1}px`;
            tempLine.style.top = `${y1 - 5}px`;
        }

        function removeTempLine() {
            if (tempLine) {
                tempLine.remove();
                tempLine = null;
            }
        }

        function showGameOverMessage() {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');

            if (!messageBox || !messageText) {
                console.error("Элементы messageBox или messageText не найдены");
                return;
            }

            // Устанавливаем текст сообщения
            messageText.textContent = "Время закончилось! Вы проиграли.";

            // Меняем фон плашки на красный
            messageBox.style.backgroundColor = "#ffcccc"; // Красный фон
            messageBox.style.color = "red"; // Красный текст

            // Показываем плашку
            messageBox.style.display = "block";
            messageBox.style.opacity = "1";

            // Отключаем взаимодействие с игровым полем
            disableGameInteraction();

            // Автоматическое скрытие через 10 секунд
            setTimeout(() => {
                hideMessage();
            }, 10000); // 10 секунд
        }

        function showSuccessMessage() {
            showMessage("Поздравляем! Вы успешно завершили игру!");
            stopTimer();
            score += 1;
            updateScore();
            disableGameInteraction();
        }

        function disableGameInteraction() {
            const allCells = document.querySelectorAll('.cell');
            if (allCells.length === 0) return; // Проверяем, есть ли ячейки на игровом поле

            allCells.forEach(cell => {
                cell.removeEventListener('mousedown', handleMouseDown);
                cell.removeEventListener('mousemove', handleMouseMove);
                cell.removeEventListener('mouseup', handleMouseUp);
            });
        }

        function showMessage(message) {
            console.log("showMessage вызвана с сообщением:", message); // Отладочный вывод
            const messageContainer = document.getElementById('messageContainer');

            if (!messageContainer) {
                console.error("Контейнер для сообщений не найден");
                return;
            }

            // Создаем новое сообщение
            const messageBox = document.createElement('div');
            messageBox.classList.add('message-box');

            // Создаем текст сообщения
            const messageText = document.createElement('span');
            messageText.textContent = message;

            // Создаем кнопку "крестик" для закрытия сообщения
            const closeButton = document.createElement('button');
            closeButton.classList.add('close-button');
            closeButton.textContent = '×';
            closeButton.onclick = () => {
                messageBox.style.transform = 'translateX(5px)'; // Двигаем вправо
                messageBox.style.opacity = '0'; // Уменьшаем прозрачность
                setTimeout(() => {
                    messageBox.remove(); // Удаляем сообщение из DOM
                }, 300); // Учитываем время анимации
            };

            // Добавляем текст и кнопку в сообщение
            messageBox.appendChild(messageText);
            messageBox.appendChild(closeButton);

            // Добавляем сообщение в контейнер
            messageContainer.appendChild(messageBox);

            // Показываем сообщение с анимацией
            setTimeout(() => {
                messageBox.style.opacity = '1';
            }, 100);

            // Удаляем сообщение через заданное время с анимацией исчезновения
            setTimeout(() => {
                if (messageBox.parentElement) { // Проверяем, что сообщение еще существует
                    messageBox.style.transform = 'translateX(5px)'; // Двигаем вправо
                    messageBox.style.opacity = '0'; // Уменьшаем прозрачность
                    setTimeout(() => {
                        messageBox.remove(); // Удаляем сообщение из DOM
                    }, 300); // Учитываем время анимации
                }
            }, MESSAGE_DISPLAY_TIME); // Используем глобальную переменную
        }


        // showMessage("Это тестовое сообщение.");
        // showMessage("Еще одно сообщение с более длинным текстом.");
    </script>
</body>

</html>